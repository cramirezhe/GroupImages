<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>group_images.separate.separate API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>group_images.separate.separate</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># Created by Carlos Ramirez at 12/09/2022
import logging
import random
from typing import Optional

import matplotlib.pyplot as plt
import numpy as np
from matplotlib.offsetbox import AnnotationBbox, OffsetImage
from sklearn.cluster import KMeans
from sklearn.manifold import TSNE


class Separate:
    def __init__(self, dict_imgs: dict, min_cluster: int = 2, max_cluster: int = 3):
        &#34;&#34;&#34;
        Initializes the class that will separate images in clusters.
        Args:
            dict_imgs (dict): dictionary in format key=image_path value=image_features
            min_cluster (int): start point to search for optimal # of cluster
            max_cluster (int): limit # of clusters
        &#34;&#34;&#34;
        self._dict_imgs = dict_imgs
        # Verify min and max values
        self._min_cluster = max(2, min_cluster)
        self._max_cluster = max_cluster
        self._best_model = None  # type: Optional[KMeans]
        if self._min_cluster &gt; self._max_cluster:
            tmp = self._min_cluster
            self._min_cluster = self._max_cluster
            self._max_cluster = tmp
        keys = list(self._dict_imgs.keys())
        # Max cluster must be smaller than the number of images
        if len(keys) &lt;= self._max_cluster:
            raise ValueError(&#34;max_cluster must be smaller than the number of images&#34;)

    def update_images(self, dict_imgs: dict) -&gt; None:
        &#34;&#34;&#34;Updates the dictionary of images&#34;&#34;&#34;
        if not isinstance(dict_imgs, dict):
            raise ValueError(&#34;Please provide a dict with the format &#34;
                             &#34;key=image_path, value=image features&#34;)
        self._dict_imgs = dict_imgs

    def set_min_cluster(self, min_cluster: int) -&gt; None:
        &#34;&#34;&#34;Updates the start point to look for clusters, raises ValueError in case of error&#34;&#34;&#34;
        if min_cluster &lt;= 0:
            raise ValueError(&#34;Please use a positive number to update min_cluster&#34;)
        if min_cluster &gt;= self._max_cluster:
            logging.warning(f&#34;{min_cluster} is greater than current limit, update first&#34;
                            f&#34;max_cluster before continuing&#34;)
        else:
            self._min_cluster = min_cluster

    def set_max_cluster(self, max_cluster: int) -&gt; None:
        &#34;&#34;&#34;Update limit # of clusters, raises ValueError in case of error&#34;&#34;&#34;
        if max_cluster &lt;= 0:
            raise ValueError(&#34;Please use a positive number to update max_cluster&#34;)
        if max_cluster &lt;= self._min_cluster:
            logging.warning(f&#34;{max_cluster} is smaller than min_cluster, update first&#34;
                            f&#34;min_cluster before continuing&#34;)
        else:
            self._max_cluster = max_cluster

    def get_max_cluster(self) -&gt; int:
        &#34;&#34;&#34;Get current limit of clusters&#34;&#34;&#34;
        return self._max_cluster

    def get_min_cluster(self) -&gt; int:
        &#34;&#34;&#34;Get current minimum # of clusters&#34;&#34;&#34;
        return self._min_cluster

    def get_dict_imgs(self) -&gt; dict:
        &#34;&#34;&#34;Return dictionary of images -&gt; feature vectors&#34;&#34;&#34;
        return self._dict_imgs

    def cluster_images(self, iterations: int = 100, random_state: Optional[int] = None,
                       early_stop_inertia: float = 0.0) -&gt; dict:
        &#34;&#34;&#34;
        Search for the optimal # of clusters for a given set of images
        Args:
            iterations (int): # of iteration to run clustering fit algorithm
            random_state (Optional[int]): random_state to reproduce result, by default it is None
            early_stop_inertia (float): value to stop looking for optimal cluster if cluster
                                        inertia is smaller than this value

        Returns:
            dict: A dictionary with key=image_path and value=matching cluster
        &#34;&#34;&#34;
        # Get the features from our dictionary as a list
        features = list(self._dict_imgs.values())
        # Cast it to numpy array
        features = np.array(features)
        best_inertia = np.inf
        best_model = None
        best_cluster = 0
        for n_clusters in range(self._min_cluster, self._max_cluster + 1):
            logging.info(f&#34;Trying {n_clusters} clusters...&#34;)
            kmeans = KMeans(n_clusters=n_clusters, max_iter=iterations,
                            random_state=random_state)
            kmeans.fit(features)
            logging.info(f&#34;\t Inertia for cluster was: {kmeans.inertia_}&#34;)
            if best_inertia &gt; kmeans.inertia_ or early_stop_inertia &gt; kmeans.inertia_:
                # Update to best cluster
                best_model = kmeans
                best_inertia = kmeans.inertia_
                best_cluster = n_clusters
        # Update our best model
        self._best_model = best_model
        logging.info(f&#34;Best cluster is {best_cluster} with inertia {best_inertia}&#34;)
        out_dict = {}
        for idx, (image_path, feature) in enumerate(self._dict_imgs.items()):
            out_dict[image_path] = self._best_model.labels_[idx]
        return out_dict

    def _get_examples_scatter(self):
        &#34;&#34;&#34;Randomly select one element from our database to draw in the scatterplot per cluster&#34;&#34;&#34;
        labels = self._best_model.labels_
        # Grab all examples
        all_examples = {}
        for idx, (image_path, _) in enumerate(self._dict_imgs.items()):
            current_label = labels[idx]
            if all_examples.get(current_label, None) is None:
                all_examples[current_label] = [image_path]
            else:
                all_examples[current_label].append(image_path)
        # Select randomly one element
        examples = {}
        for label, images_paths in all_examples.items():
            examples[label] = {
                &#39;image_path&#39;: random.choice(images_paths),
                &#39;max_x&#39;: -np.inf,
                &#39;min_x&#39;: np.inf,
                &#39;max_y&#39;: -np.inf,
                &#39;min_y&#39;: np.inf
            }
        return examples

    def _draw_examples_plot(self, ax, z, zoom):
        &#34;&#34;&#34;Draw our selected example from _get_examples_scatter in our plot&#34;&#34;&#34;
        labels = self._best_model.labels_
        examples = self._get_examples_scatter()
        for idx in range(len(labels)):
            examples[labels[idx]][&#39;max_x&#39;] = max(examples[labels[idx]][&#39;max_x&#39;], z[idx, 0])
            examples[labels[idx]][&#39;min_x&#39;] = min(examples[labels[idx]][&#39;min_x&#39;], z[idx, 0])
            examples[labels[idx]][&#39;max_y&#39;] = max(examples[labels[idx]][&#39;max_y&#39;], z[idx, 1])
            examples[labels[idx]][&#39;min_y&#39;] = min(examples[labels[idx]][&#39;min_x&#39;], z[idx, 1])
        for label, metadata in examples.items():
            x_coor = metadata[&#39;min_x&#39;] + (metadata[&#39;max_x&#39;] - metadata[&#39;min_x&#39;]) / 2
            y_coor = metadata[&#39;min_y&#39;] + (metadata[&#39;max_y&#39;] - metadata[&#39;min_y&#39;]) / 2
            image = plt.imread(metadata[&#39;image_path&#39;])
            im = OffsetImage(image, zoom=zoom)
            ab = AnnotationBbox(im, (x_coor, y_coor), frameon=False)
            ax.add_artist(ab)

    def plot_vectors(self, random_state: Optional[int] = None,
                     zoom: Optional[float] = 0.05) -&gt; None:
        &#34;&#34;&#34;
        Experimental feature, plot images features in a 2d graph with an image in the
        Args:
            random_state Optional[int]: optional int value to get random values
            zoom: zoom to use in order to draw images in the plot values smaller than 1.0
                  will decrease the images, otherwise it will increase

        Returns:
            None
        &#34;&#34;&#34;
        if self._best_model is None:
            logging.warning(&#34;Please fit the data before plotting it.&#34;)
            return
        if zoom &lt;= 0.0:
            raise ValueError(&#34;zoom parameter must be positive&#34;)
        labels = self._best_model.labels_
        n_clusters = self._best_model.cluster_centers_.shape[0]
        # Get the features from our dictionary as a list
        features = list(self._dict_imgs.values())
        # Cast it to numpy array
        features = np.array(features)
        tsne = TSNE(n_components=2, verbose=0, random_state=random_state,
                    perplexity=features.shape[0] / n_clusters)
        # fit the data
        z = tsne.fit_transform(features)
        # if everything work correctly, grab an example of every cluster
        fig, ax = plt.subplots()
        ax.scatter(x=z[:, 0], y=z[:, 1], c=labels)
        ax.set_title(&#39;Clusters in data&#39;)
        ax.set(xlabel=&#39;comp-1&#39;, ylabel=&#39;comp-2&#39;)
        # Draw images in plot
        self._draw_examples_plot(ax, z, zoom)
        plt.show()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="group_images.separate.separate.Separate"><code class="flex name class">
<span>class <span class="ident">Separate</span></span>
<span>(</span><span>dict_imgs: dict, min_cluster: int = 2, max_cluster: int = 3)</span>
</code></dt>
<dd>
<div class="desc"><p>Initializes the class that will separate images in clusters.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>dict_imgs</code></strong> :&ensp;<code>dict</code></dt>
<dd>dictionary in format key=image_path value=image_features</dd>
<dt><strong><code>min_cluster</code></strong> :&ensp;<code>int</code></dt>
<dd>start point to search for optimal # of cluster</dd>
<dt><strong><code>max_cluster</code></strong> :&ensp;<code>int</code></dt>
<dd>limit # of clusters</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Separate:
    def __init__(self, dict_imgs: dict, min_cluster: int = 2, max_cluster: int = 3):
        &#34;&#34;&#34;
        Initializes the class that will separate images in clusters.
        Args:
            dict_imgs (dict): dictionary in format key=image_path value=image_features
            min_cluster (int): start point to search for optimal # of cluster
            max_cluster (int): limit # of clusters
        &#34;&#34;&#34;
        self._dict_imgs = dict_imgs
        # Verify min and max values
        self._min_cluster = max(2, min_cluster)
        self._max_cluster = max_cluster
        self._best_model = None  # type: Optional[KMeans]
        if self._min_cluster &gt; self._max_cluster:
            tmp = self._min_cluster
            self._min_cluster = self._max_cluster
            self._max_cluster = tmp
        keys = list(self._dict_imgs.keys())
        # Max cluster must be smaller than the number of images
        if len(keys) &lt;= self._max_cluster:
            raise ValueError(&#34;max_cluster must be smaller than the number of images&#34;)

    def update_images(self, dict_imgs: dict) -&gt; None:
        &#34;&#34;&#34;Updates the dictionary of images&#34;&#34;&#34;
        if not isinstance(dict_imgs, dict):
            raise ValueError(&#34;Please provide a dict with the format &#34;
                             &#34;key=image_path, value=image features&#34;)
        self._dict_imgs = dict_imgs

    def set_min_cluster(self, min_cluster: int) -&gt; None:
        &#34;&#34;&#34;Updates the start point to look for clusters, raises ValueError in case of error&#34;&#34;&#34;
        if min_cluster &lt;= 0:
            raise ValueError(&#34;Please use a positive number to update min_cluster&#34;)
        if min_cluster &gt;= self._max_cluster:
            logging.warning(f&#34;{min_cluster} is greater than current limit, update first&#34;
                            f&#34;max_cluster before continuing&#34;)
        else:
            self._min_cluster = min_cluster

    def set_max_cluster(self, max_cluster: int) -&gt; None:
        &#34;&#34;&#34;Update limit # of clusters, raises ValueError in case of error&#34;&#34;&#34;
        if max_cluster &lt;= 0:
            raise ValueError(&#34;Please use a positive number to update max_cluster&#34;)
        if max_cluster &lt;= self._min_cluster:
            logging.warning(f&#34;{max_cluster} is smaller than min_cluster, update first&#34;
                            f&#34;min_cluster before continuing&#34;)
        else:
            self._max_cluster = max_cluster

    def get_max_cluster(self) -&gt; int:
        &#34;&#34;&#34;Get current limit of clusters&#34;&#34;&#34;
        return self._max_cluster

    def get_min_cluster(self) -&gt; int:
        &#34;&#34;&#34;Get current minimum # of clusters&#34;&#34;&#34;
        return self._min_cluster

    def get_dict_imgs(self) -&gt; dict:
        &#34;&#34;&#34;Return dictionary of images -&gt; feature vectors&#34;&#34;&#34;
        return self._dict_imgs

    def cluster_images(self, iterations: int = 100, random_state: Optional[int] = None,
                       early_stop_inertia: float = 0.0) -&gt; dict:
        &#34;&#34;&#34;
        Search for the optimal # of clusters for a given set of images
        Args:
            iterations (int): # of iteration to run clustering fit algorithm
            random_state (Optional[int]): random_state to reproduce result, by default it is None
            early_stop_inertia (float): value to stop looking for optimal cluster if cluster
                                        inertia is smaller than this value

        Returns:
            dict: A dictionary with key=image_path and value=matching cluster
        &#34;&#34;&#34;
        # Get the features from our dictionary as a list
        features = list(self._dict_imgs.values())
        # Cast it to numpy array
        features = np.array(features)
        best_inertia = np.inf
        best_model = None
        best_cluster = 0
        for n_clusters in range(self._min_cluster, self._max_cluster + 1):
            logging.info(f&#34;Trying {n_clusters} clusters...&#34;)
            kmeans = KMeans(n_clusters=n_clusters, max_iter=iterations,
                            random_state=random_state)
            kmeans.fit(features)
            logging.info(f&#34;\t Inertia for cluster was: {kmeans.inertia_}&#34;)
            if best_inertia &gt; kmeans.inertia_ or early_stop_inertia &gt; kmeans.inertia_:
                # Update to best cluster
                best_model = kmeans
                best_inertia = kmeans.inertia_
                best_cluster = n_clusters
        # Update our best model
        self._best_model = best_model
        logging.info(f&#34;Best cluster is {best_cluster} with inertia {best_inertia}&#34;)
        out_dict = {}
        for idx, (image_path, feature) in enumerate(self._dict_imgs.items()):
            out_dict[image_path] = self._best_model.labels_[idx]
        return out_dict

    def _get_examples_scatter(self):
        &#34;&#34;&#34;Randomly select one element from our database to draw in the scatterplot per cluster&#34;&#34;&#34;
        labels = self._best_model.labels_
        # Grab all examples
        all_examples = {}
        for idx, (image_path, _) in enumerate(self._dict_imgs.items()):
            current_label = labels[idx]
            if all_examples.get(current_label, None) is None:
                all_examples[current_label] = [image_path]
            else:
                all_examples[current_label].append(image_path)
        # Select randomly one element
        examples = {}
        for label, images_paths in all_examples.items():
            examples[label] = {
                &#39;image_path&#39;: random.choice(images_paths),
                &#39;max_x&#39;: -np.inf,
                &#39;min_x&#39;: np.inf,
                &#39;max_y&#39;: -np.inf,
                &#39;min_y&#39;: np.inf
            }
        return examples

    def _draw_examples_plot(self, ax, z, zoom):
        &#34;&#34;&#34;Draw our selected example from _get_examples_scatter in our plot&#34;&#34;&#34;
        labels = self._best_model.labels_
        examples = self._get_examples_scatter()
        for idx in range(len(labels)):
            examples[labels[idx]][&#39;max_x&#39;] = max(examples[labels[idx]][&#39;max_x&#39;], z[idx, 0])
            examples[labels[idx]][&#39;min_x&#39;] = min(examples[labels[idx]][&#39;min_x&#39;], z[idx, 0])
            examples[labels[idx]][&#39;max_y&#39;] = max(examples[labels[idx]][&#39;max_y&#39;], z[idx, 1])
            examples[labels[idx]][&#39;min_y&#39;] = min(examples[labels[idx]][&#39;min_x&#39;], z[idx, 1])
        for label, metadata in examples.items():
            x_coor = metadata[&#39;min_x&#39;] + (metadata[&#39;max_x&#39;] - metadata[&#39;min_x&#39;]) / 2
            y_coor = metadata[&#39;min_y&#39;] + (metadata[&#39;max_y&#39;] - metadata[&#39;min_y&#39;]) / 2
            image = plt.imread(metadata[&#39;image_path&#39;])
            im = OffsetImage(image, zoom=zoom)
            ab = AnnotationBbox(im, (x_coor, y_coor), frameon=False)
            ax.add_artist(ab)

    def plot_vectors(self, random_state: Optional[int] = None,
                     zoom: Optional[float] = 0.05) -&gt; None:
        &#34;&#34;&#34;
        Experimental feature, plot images features in a 2d graph with an image in the
        Args:
            random_state Optional[int]: optional int value to get random values
            zoom: zoom to use in order to draw images in the plot values smaller than 1.0
                  will decrease the images, otherwise it will increase

        Returns:
            None
        &#34;&#34;&#34;
        if self._best_model is None:
            logging.warning(&#34;Please fit the data before plotting it.&#34;)
            return
        if zoom &lt;= 0.0:
            raise ValueError(&#34;zoom parameter must be positive&#34;)
        labels = self._best_model.labels_
        n_clusters = self._best_model.cluster_centers_.shape[0]
        # Get the features from our dictionary as a list
        features = list(self._dict_imgs.values())
        # Cast it to numpy array
        features = np.array(features)
        tsne = TSNE(n_components=2, verbose=0, random_state=random_state,
                    perplexity=features.shape[0] / n_clusters)
        # fit the data
        z = tsne.fit_transform(features)
        # if everything work correctly, grab an example of every cluster
        fig, ax = plt.subplots()
        ax.scatter(x=z[:, 0], y=z[:, 1], c=labels)
        ax.set_title(&#39;Clusters in data&#39;)
        ax.set(xlabel=&#39;comp-1&#39;, ylabel=&#39;comp-2&#39;)
        # Draw images in plot
        self._draw_examples_plot(ax, z, zoom)
        plt.show()</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="group_images.separate.separate.Separate.cluster_images"><code class="name flex">
<span>def <span class="ident">cluster_images</span></span>(<span>self, iterations: int = 100, random_state: Optional[int] = None, early_stop_inertia: float = 0.0) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"><p>Search for the optimal # of clusters for a given set of images</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>iterations</code></strong> :&ensp;<code>int</code></dt>
<dd>
<h1 id="of-iteration-to-run-clustering-fit-algorithm">of iteration to run clustering fit algorithm</h1>
</dd>
<dt><strong><code>random_state</code></strong> :&ensp;<code>Optional[int]</code></dt>
<dd>random_state to reproduce result, by default it is None</dd>
<dt><strong><code>early_stop_inertia</code></strong> :&ensp;<code>float</code></dt>
<dd>value to stop looking for optimal cluster if cluster
inertia is smaller than this value</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>A dictionary with key=image_path and value=matching cluster</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cluster_images(self, iterations: int = 100, random_state: Optional[int] = None,
                   early_stop_inertia: float = 0.0) -&gt; dict:
    &#34;&#34;&#34;
    Search for the optimal # of clusters for a given set of images
    Args:
        iterations (int): # of iteration to run clustering fit algorithm
        random_state (Optional[int]): random_state to reproduce result, by default it is None
        early_stop_inertia (float): value to stop looking for optimal cluster if cluster
                                    inertia is smaller than this value

    Returns:
        dict: A dictionary with key=image_path and value=matching cluster
    &#34;&#34;&#34;
    # Get the features from our dictionary as a list
    features = list(self._dict_imgs.values())
    # Cast it to numpy array
    features = np.array(features)
    best_inertia = np.inf
    best_model = None
    best_cluster = 0
    for n_clusters in range(self._min_cluster, self._max_cluster + 1):
        logging.info(f&#34;Trying {n_clusters} clusters...&#34;)
        kmeans = KMeans(n_clusters=n_clusters, max_iter=iterations,
                        random_state=random_state)
        kmeans.fit(features)
        logging.info(f&#34;\t Inertia for cluster was: {kmeans.inertia_}&#34;)
        if best_inertia &gt; kmeans.inertia_ or early_stop_inertia &gt; kmeans.inertia_:
            # Update to best cluster
            best_model = kmeans
            best_inertia = kmeans.inertia_
            best_cluster = n_clusters
    # Update our best model
    self._best_model = best_model
    logging.info(f&#34;Best cluster is {best_cluster} with inertia {best_inertia}&#34;)
    out_dict = {}
    for idx, (image_path, feature) in enumerate(self._dict_imgs.items()):
        out_dict[image_path] = self._best_model.labels_[idx]
    return out_dict</code></pre>
</details>
</dd>
<dt id="group_images.separate.separate.Separate.get_dict_imgs"><code class="name flex">
<span>def <span class="ident">get_dict_imgs</span></span>(<span>self) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"><p>Return dictionary of images -&gt; feature vectors</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_dict_imgs(self) -&gt; dict:
    &#34;&#34;&#34;Return dictionary of images -&gt; feature vectors&#34;&#34;&#34;
    return self._dict_imgs</code></pre>
</details>
</dd>
<dt id="group_images.separate.separate.Separate.get_max_cluster"><code class="name flex">
<span>def <span class="ident">get_max_cluster</span></span>(<span>self) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Get current limit of clusters</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_max_cluster(self) -&gt; int:
    &#34;&#34;&#34;Get current limit of clusters&#34;&#34;&#34;
    return self._max_cluster</code></pre>
</details>
</dd>
<dt id="group_images.separate.separate.Separate.get_min_cluster"><code class="name flex">
<span>def <span class="ident">get_min_cluster</span></span>(<span>self) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Get current minimum # of clusters</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_min_cluster(self) -&gt; int:
    &#34;&#34;&#34;Get current minimum # of clusters&#34;&#34;&#34;
    return self._min_cluster</code></pre>
</details>
</dd>
<dt id="group_images.separate.separate.Separate.plot_vectors"><code class="name flex">
<span>def <span class="ident">plot_vectors</span></span>(<span>self, random_state: Optional[int] = None, zoom: Optional[float] = 0.05) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Experimental feature, plot images features in a 2d graph with an image in the</p>
<h2 id="args">Args</h2>
<dl>
<dt>random_state Optional[int]: optional int value to get random values</dt>
<dt><strong><code>zoom</code></strong></dt>
<dd>zoom to use in order to draw images in the plot values smaller than 1.0
will decrease the images, otherwise it will increase</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_vectors(self, random_state: Optional[int] = None,
                 zoom: Optional[float] = 0.05) -&gt; None:
    &#34;&#34;&#34;
    Experimental feature, plot images features in a 2d graph with an image in the
    Args:
        random_state Optional[int]: optional int value to get random values
        zoom: zoom to use in order to draw images in the plot values smaller than 1.0
              will decrease the images, otherwise it will increase

    Returns:
        None
    &#34;&#34;&#34;
    if self._best_model is None:
        logging.warning(&#34;Please fit the data before plotting it.&#34;)
        return
    if zoom &lt;= 0.0:
        raise ValueError(&#34;zoom parameter must be positive&#34;)
    labels = self._best_model.labels_
    n_clusters = self._best_model.cluster_centers_.shape[0]
    # Get the features from our dictionary as a list
    features = list(self._dict_imgs.values())
    # Cast it to numpy array
    features = np.array(features)
    tsne = TSNE(n_components=2, verbose=0, random_state=random_state,
                perplexity=features.shape[0] / n_clusters)
    # fit the data
    z = tsne.fit_transform(features)
    # if everything work correctly, grab an example of every cluster
    fig, ax = plt.subplots()
    ax.scatter(x=z[:, 0], y=z[:, 1], c=labels)
    ax.set_title(&#39;Clusters in data&#39;)
    ax.set(xlabel=&#39;comp-1&#39;, ylabel=&#39;comp-2&#39;)
    # Draw images in plot
    self._draw_examples_plot(ax, z, zoom)
    plt.show()</code></pre>
</details>
</dd>
<dt id="group_images.separate.separate.Separate.set_max_cluster"><code class="name flex">
<span>def <span class="ident">set_max_cluster</span></span>(<span>self, max_cluster: int) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Update limit # of clusters, raises ValueError in case of error</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_max_cluster(self, max_cluster: int) -&gt; None:
    &#34;&#34;&#34;Update limit # of clusters, raises ValueError in case of error&#34;&#34;&#34;
    if max_cluster &lt;= 0:
        raise ValueError(&#34;Please use a positive number to update max_cluster&#34;)
    if max_cluster &lt;= self._min_cluster:
        logging.warning(f&#34;{max_cluster} is smaller than min_cluster, update first&#34;
                        f&#34;min_cluster before continuing&#34;)
    else:
        self._max_cluster = max_cluster</code></pre>
</details>
</dd>
<dt id="group_images.separate.separate.Separate.set_min_cluster"><code class="name flex">
<span>def <span class="ident">set_min_cluster</span></span>(<span>self, min_cluster: int) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Updates the start point to look for clusters, raises ValueError in case of error</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_min_cluster(self, min_cluster: int) -&gt; None:
    &#34;&#34;&#34;Updates the start point to look for clusters, raises ValueError in case of error&#34;&#34;&#34;
    if min_cluster &lt;= 0:
        raise ValueError(&#34;Please use a positive number to update min_cluster&#34;)
    if min_cluster &gt;= self._max_cluster:
        logging.warning(f&#34;{min_cluster} is greater than current limit, update first&#34;
                        f&#34;max_cluster before continuing&#34;)
    else:
        self._min_cluster = min_cluster</code></pre>
</details>
</dd>
<dt id="group_images.separate.separate.Separate.update_images"><code class="name flex">
<span>def <span class="ident">update_images</span></span>(<span>self, dict_imgs: dict) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Updates the dictionary of images</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_images(self, dict_imgs: dict) -&gt; None:
    &#34;&#34;&#34;Updates the dictionary of images&#34;&#34;&#34;
    if not isinstance(dict_imgs, dict):
        raise ValueError(&#34;Please provide a dict with the format &#34;
                         &#34;key=image_path, value=image features&#34;)
    self._dict_imgs = dict_imgs</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="group_images.separate" href="index.html">group_images.separate</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="group_images.separate.separate.Separate" href="#group_images.separate.separate.Separate">Separate</a></code></h4>
<ul class="two-column">
<li><code><a title="group_images.separate.separate.Separate.cluster_images" href="#group_images.separate.separate.Separate.cluster_images">cluster_images</a></code></li>
<li><code><a title="group_images.separate.separate.Separate.get_dict_imgs" href="#group_images.separate.separate.Separate.get_dict_imgs">get_dict_imgs</a></code></li>
<li><code><a title="group_images.separate.separate.Separate.get_max_cluster" href="#group_images.separate.separate.Separate.get_max_cluster">get_max_cluster</a></code></li>
<li><code><a title="group_images.separate.separate.Separate.get_min_cluster" href="#group_images.separate.separate.Separate.get_min_cluster">get_min_cluster</a></code></li>
<li><code><a title="group_images.separate.separate.Separate.plot_vectors" href="#group_images.separate.separate.Separate.plot_vectors">plot_vectors</a></code></li>
<li><code><a title="group_images.separate.separate.Separate.set_max_cluster" href="#group_images.separate.separate.Separate.set_max_cluster">set_max_cluster</a></code></li>
<li><code><a title="group_images.separate.separate.Separate.set_min_cluster" href="#group_images.separate.separate.Separate.set_min_cluster">set_min_cluster</a></code></li>
<li><code><a title="group_images.separate.separate.Separate.update_images" href="#group_images.separate.separate.Separate.update_images">update_images</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>